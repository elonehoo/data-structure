# 算法

## 算法的特性

### 1. 输入和输出

```markdown
# 输入输出
> 输入和输出特性比较容易理解，`算法具有零个或者多个输入`。尽管对于绝大多数算法来说，输入参数都是十分必要的。但是对于个别的情况，如打印**“hello world!”**这样的代码，不需要任何输入输出参数，因此算法可以是零个。`算法至少有一个或者多个输出，算法是一定需要输出的`，不需要输出，那么就是不需要算法的。输出的形式可以是打印输出，也可以是返回一个或者多个值等。
```

### 2. 有穷性

```markdown
# 有穷性
> [有穷性](指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤都在可接受的时间范围内完成。)
> 现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用中合理的、可以接受的“有边界”。我们写了一个算法，计算机需要计算二十多年，一定会结束，它在数学意义上是有穷的，可是时间过于长了，这个算法的意义也就不大了。
```

### 3. 确定性

```markdown
# 确定性
> [确定性](算法的每一个步骤都具有确定的含义，不会出现二义性。)
> 算法在一定条件爱那些爱，只有一条执行路径，相同的输入只能有唯一的输出的结果。算法的每一个步骤都被精确定义而无歧义。
```

### 4. 可行性

```markdown
# 可行性 
> [可行性](算法的每一步都必须是可行的，也就是说明，每一步都能通过执行有限的次数完成。)
> 可行性意味着算法可以转换为程序上机运行，并得到正确的结果，尽管在目前计算机界也存在那种没有实现的极为复杂的算法，不是说理论上不能实现，而是因为过于复杂，我们当今的编程方法、工具、大脑限制了这个工作，不过这都是理论研究领域的问题。
```

## 算法设计的要求

### 1. 正确性

```markdown
# 正确性
> [正确性](算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确的反映问题的需求、能够的到问题的正确答案。)
> 但是算法的“正确”通常在用法上有很大的差别，大体分为四个层次。
>> 1. 算法程序没有语法错误。
>> 2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。
>> 3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
>> 4. 算法程序对于精心选择的，甚至刁难的测数据都有满足要求的输出结果。
```

### 2. 可读性

```markdown
# 可读性
> [可读性](算法设计的另一个目的就是为了便于阅读、理解和交流。)
> 可读性高可以帮助同学理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。
> 我们写代码的目的，一方面是为了让计算机执行，但还有一个重要哦的目的是为了便于他人进行阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间久了，自己都不知道自己写了什么。可读性是算法(也包括实现它的代码)好坏的很重要的标志。
```

### 3. 健壮性

```markdown
# 健壮性 
> 一个好的算法还应该可以对输入的数据不合法的情况下作出合适的处理。比如输入的时间或者距离不应该是负数等。
> [健壮性](当输入的数据不合法的时候，算法也能做出对应的处理，而不是产生异常或者莫名其妙的错误。)
```

### 4. 时间效率高和存储量低

```markdown
> [时间效率](指的是算法执行的时间)
> 对于同一个问题，如果有多个算法可以解决，执行时间短的算法效率高，执行时间长的效率低。
> [存储量需求](指的是算法在执行过程中需要的最大存储空间，只要指算法在程序运行时所占用的内存或者外部硬盘存储空间，主要指的是算法程序运行时所占用的内存或者外部存储空间。)
> 我们设计的算法应该尽量满足时间效率高和存储量低的需求。在生活中，人们都希望花费最少的钱、用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，花最少存储空间，花最小的时间，办成同样的事情就是好的算法。
```

> 综上所述，好的算法，应该具有`正确性`、`可读性`，`健壮性`，`高效率`和`低存储量`的特征。

## 算法效率的度量方法

### 1. 事后统计方法

```markdown
# 事后统计方法 
> [事后统计方法](这种方法主要是通过设计好的测试程序和数据，利用计算机时期对于不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低。)
> 但是这种度量方式还是有很大的缺陷的
>> 1. 必须依据算法事先编制好的程序，这通常都需要花费大量的时间和精力。如果编制出来发现它的根本很糟糕的算法，那不就是白忙活了吗？
>> 2. 时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。要知道，选择一台四核处理器的计算机，跟当年286，386，486等老爷机相比，在处理算法的运算速度上，是不能进行相提并论的；而所用的操作系统、编辑器、运行框架等软件的不同，也可能影响到他们的结果；就算事同一台机器，CPU使用率和内存情况不一样，也会造成细微的差异。
>> 3. 算法的测试数据设计困难，并且程序的运行时间往往还和测试数据的规模有很大的关系，效率高的算法在小的测试数据面前往往得不到体现。比如10个数字的排序，不管用什么算法，差异几乎是零。而如果有一百万个随机数字排序，那不同的算法的差异就非常大了，那么我们为了比较算法，到底用多少数据来测试，这也是难以判断的问题。
```

### 2. 事前分析估算方法

```markdown
# 事前分析估算方法
> [事前分析估算方法](在计算机程序编制前，依据统计方法对算法进行估算。)
>> 1. `[算法采用的策略、方法。](算法好坏的根本)`
>> 2. `[编译产生的代码质量。](软件来进行支持)`
>> 3. `[问题的输入规模。](算法的基础)`
>> 4. `[机器执行指令的速度。](硬件的性能)`
```

## 算法时间复杂度

### 1. 算法时间复杂度定义

```markdown
在进行算法分析时，语句总的值系数`T(n)`是关于问题规模`n`的函数，进而分析`T(n)`随着`n`的变化情况并确定`T(n)`的数量级。算法的时间复杂度，也就是算法的时间量度，记作：`T(n) = O(f(n))`。它表示随着问题规模`n`的增大，算法执行时间的增长率和`f(n)`的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中`f(n)`是问题规模`n`的某个函数。
这样就用大写`O()`来体现算法时间复杂度的记法，我们称之为**大O记法**。
一般情况下，随着`n`的增大，`T(n)`的增长最慢的算法为最优算法。
```

### 2. 推导大O阶方法

```markdown
> 推导大O阶方法 
>> 1. 用常数1取代运行时间的所有加法常数。
>> 2. 在修改后的运行次数函数中，只保留最高阶段。
>> 3. 如果最高阶段存在且不是1，则除去这个项相乘的常数。
>> 4. 得到的结果就是大O阶。
```



